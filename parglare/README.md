## Установка
```python3
pip install parglare
```

## Описание функциональности
`parglare` - это LR/GLR парсер. Ему не требуется лексер, этот парсер использует встроенный сканнер, который пытается распознать токен по ходу парсинга. Это помогает не думать о лексических неоднозначностях.

Таким образом, для использования этого парсера достаточно описать [грамматику](https://github.com/alexbuyan/fl-2021-hse-win/blob/proj/parglare/grammar.pg) и [парсер](https://github.com/alexbuyan/fl-2021-hse-win/blob/proj/parglare/glr_parser.py) (который занимает около 20 строк).

Также у парсера есть встроенный визуализатор в `.dot` файлы (которые потом можно преобразовать `.png`, `.pdf` файлы). Это можно сделать с помощью следующих команд:

```
pglr --debug compile grammar.pg // дает детальную информацию о грамматике

// для однозначных грамматик (LR парсер)
pglr viz grammar.pg // визуализирует автомат

// для неоднозначных грамматик (GLR парсер)
pglr trace grammar.pg // показывает путь, по которому обходил GLR парсер
pglr parse grammar.pg --glr // выводит леса и деревья парсинга (в зависимости от однозначности грамматики)

// используется для преобразования .dot файлов
dot -Tpng *.dot -O *.dot.png 
dot -Tpdf *.dot -O *.dot.pdf
```

Это лишь малая часть того, что умеет парсер. Вся функциональность описана в подробной [документации](http://www.igordejanovic.net/parglare/stable/)

## Преимущества парсера
Основное преимущество - GLR режим. Он сам разбирается с shift/reduce конфликтами, при этом выдает все возможные варианты разбора. Это дает преимущество в скорости работы на одном и том же наборе входных данных - `parglare` работает за `~20` секунд, в то время как `ANTLR` работает за `~500` секунд. Это связано с неоднозначностью грамматики - с увеличением слова количество неоднозначностей очень быстро растет

Размер ввода (количество символов) | Количество неоднозначностей | Количество найденных решений | Время работы
------------- | ------------- | ------------- | -------------
5 | 7 | 41 | 0.0019
10 | 72 | 136361 | 0.014
15 | 212 | 811716250 | 0.076
20 | 427 | 5957027065972 | 0.264
... | ... | ... | ...
50 | 3292 | 3570762510330241248964023620469730419 | 18.399 
... | ... | ... | ...
75 | 7742 | 412216510593215345629362419941132141404199148321406353295 | 100.754

## Недостатки парсера
К сожалению, визуализаторы `trace` и `parse` работают только в `debug` режиме, поэтому вся информация о дереве (и его обходе) выводится в консоль. Это, очевидно, замедляет его работу, поэтому визуализация больших деревьев практически невозможно, да и выглядит достаточно плохо. Хотелось бы видеть флаг `--silent`, при использовании которого на экран будет выводиться только дерево разбора (без всех промежуточных шагов)

Не совсем понятно, как считать свои функции во время парсинга. Для этого существую т `actions`, которые понятно как использовать с LR-парсерсом (в документации приведен пример калькулятора), который возвращает результат, потому что дерево одно. Как использовать `actions` с GLR-парсером из документации не было понятно. Какого-то результата, конечно, получилось достигнуть (при помощи `.call_actions()`), но на практике он был мало полезен и применим.