## Грамматика
Для сравнения наших генераторов мы воспользовались следующей неоднозначной грамматикой:
```
S -> SSS | SS | a    # это a+
```
При таком описании во время парсинга возникает очень много неоднозначностей, на которые было интересно посмотреть и сравнить производительность парсеров


Ту же грамматику можно записать так:
```
S -> aS | a
```
Так неоднозначностей возникать не будет и выражение разбирается за `O(n)`

## Используемые генераторы и их реализации
* [antlr4](https://github.com/alexbuyan/fl-2021-hse-win/tree/proj/antlr4) (Adaptive LL(*))
* [lark](https://github.com/alexbuyan/fl-2021-hse-win/tree/proj/lark) (Earley)
* [parglare](https://github.com/alexbuyan/fl-2021-hse-win/tree/proj/parglare) (GLR)
* [yacc](https://github.com/alexbuyan/fl-2021-hse-win/blob/proj/yacc/) (LALR(1))

Подробнее про работу каждого из генераторов можно почитать по соответствующей ссылке.

Для написания генераторов мы использовали Python3, но также понадобилась Java (для визуализации деревьев в ANTLR)

## Основные выводы
#### Время работы генераторов
Размер входных данных | ANTLR4 | Lark | Parglare | Yacc
--- | --- | --- | --- | ---
1 | 0.003 | 0.0001 | 0.00035 | 0.00008
10 | 0.263 | 0.0077 | 0.014 | 0.00014
20 | 33.994 | 0.0418 | 0.264 | 0.00025
30 | TL | 0.1155 | 1.911 | 0.00034
40 | TL | 0.2598 | 9.906 | 0.00038
50 | TL | 0.4973 | 18.399 | 0.00047
60 | TL | 0.8868 | 60.883 | 0.00056
70 | TL | 1.3198 | 162.57 | 0.00065
80 | TL | 2.0565 | 182.499 | 0.00074
90 | TL | 2.8626 | 272.041 | 0.00139
100 | TL | 4.1458 | 563.266 | 0.00178

К сожалению, не везде можно считать данное сравнение правильным, так как некоторые генераторы обязательно строят дерево/лес при парсинге, в то время как в других построение дерева можно отключить (либо его вообще нет)

#### Встроенное графическое построение деревьев
Генератор | Графическое построение деревьев
-- | --
ANTLR4 | Дерево, только при сборке под Java
Lark | Дерево
Parglare | Дерево (LR) + Лес (GLR)
Yacc | Нет